//This Shall serve as the basic template for future Arm code
char foo;
#include <Wire.h>
#include <Adafruit_MotorShield.h>
#include <Mecanum.h>
//Had an issue on Justins Comp where a duplication was occuring
//#include <Adafruit_PWMServoDriver.h>

Adafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver();

#define SERVOMIN  150 // this is the 'minimum' pulse length count (out of 4096)
#define SERVOMAX  600 // this is the 'maximum' pulse length count (out of 4096)

#define DEBUG
const float AB = 4.75;
const float BC = 5.75;
const float CT = 4.750;
const int NUM_SERVOS = 6; 
const int Front_Arm[NUM_SERVOS] = {10,11,12,13,14,15};
const int Rear_Arm[NUM_SERVOS] = {0,1,2,3,4,5};
const float rtod = 57.295779;

#define BASE_HGT 67.31      //base hight 2.65"
#define HUMERUS 146.05      //shoulder-to-elbow "bone" 5.75"
#define ULNA 187.325        //elbow-to-wrist "bone" 7.375"
#define GRIPPER 100.00          //gripper (incl.heavy duty wrist rotate mechanism) length 3.94"
 
float hum_sq = HUMERUS*HUMERUS;
float uln_sq = ULNA*ULNA;
void setup() {
   Serial.begin(9600);
   pwm.begin();
   pwm.setPWMFreq(60);  // Analog servos run at ~60 Hz updates
   int pulselen;

}

void loop() {
   #define RADIUS 80.0
  //float angle = 0;
  float zaxis,yaxis;
  for( float angle = 0.0; angle < 360.0; angle += 5.0 ) {
      yaxis = RADIUS * sin( radians( angle )) + 200;
      zaxis = RADIUS * cos( radians( angle )) + 200;
	  float yaxis2 = RADIUS * sin( radians( angle+180 )) + 200;
      float zaxis2 = RADIUS * cos( radians( angle+180 )) + 200;
      Arm_Rear( 0, yaxis, zaxis, 0 );
	  delay(1);
	  Arm_Front( 0, yaxis2, zaxis2, 0 );
      delay(1);
  }


}



int Arm_Rear(float x, float y, float z,  float Wrist_Angle) //Here's all the Inverse Kinematics to control the arm
{
	 float grip_angle_r = radians( Wrist_Angle );    //grip angle in radians for use in calculations
  /* Base angle and radial distance from x,y coordinates */
  float bas_angle_r = atan2( x, y );
  float rdist = sqrt(( x * x ) + ( y * y ));
  /* rdist is y coordinate for the arm */
  y = rdist;
  /* Grip offsets calculated based on grip angle */
  float grip_off_z = ( sin( grip_angle_r )) * GRIPPER;
  float grip_off_y = ( cos( grip_angle_r )) * GRIPPER;
  /* Wrist position */
  float wrist_z = ( z - grip_off_z ) - BASE_HGT;
  float wrist_y = y - grip_off_y;
  /* Shoulder to wrist distance ( AKA sw ) */
  float s_w = ( wrist_z * wrist_z ) + ( wrist_y * wrist_y );
  float s_w_sqrt = sqrt( s_w );
  /* s_w angle to ground */
  //float a1 = atan2( wrist_y, wrist_z );
  float a1 = atan2( wrist_z, wrist_y );
  /* s_w angle to humerus */
  float a2 = acos((( hum_sq - uln_sq ) + s_w ) / ( 2 * HUMERUS * s_w_sqrt ));
  /* shoulder angle */
  float shl_angle_r = a1 + a2;
  float Shoulder= degrees( shl_angle_r );
  /* elbow angle */
  float elb_angle_r = acos(( hum_sq + uln_sq - s_w ) / ( 2 * HUMERUS * ULNA ));
  float elb_angle_d = degrees( elb_angle_r );
  float Elbow = -( 180.0 - elb_angle_d );
  /* wrist angle */
  float Wrist = ( Wrist_Angle - Elbow ) - Shoulder;
 float Base_Rotation= degrees( bas_angle_r );
  int pulselen;

Serial.print(" Shoulder: ");
	Serial.print(Shoulder);
		Serial.print(" Elbow: " );
		Serial.print(Elbow);
	Serial.print(" Wrist: ");
	Serial.print(Wrist);
	Serial.print(" Base: ");
	Serial.print(Base_Rotation);
	Serial.print("\n \n");

  pulselen = map(Shoulder,0,180,SERVOMIN,SERVOMAX);
  pwm.setPWM(Rear_Arm[1],0,pulselen);

  
  pulselen = map(-Elbow,0,180,SERVOMIN,SERVOMAX);
  pwm.setPWM(Rear_Arm[2],0,pulselen);

  
  
  pulselen = map(180-Wrist,0,180,SERVOMIN,SERVOMAX);
  pwm.setPWM(Rear_Arm[3],0,pulselen);


  pulselen = map(Base_Rotation,0,180,SERVOMIN,SERVOMAX);
  pwm.setPWM(Rear_Arm[0],0,pulselen);
/*

  pulselen = map(Wrist,0,180,SERVOMIN,SERVOMAX);
  pwm.setPWM(Rear_Arm[4],0,pulselen);
 delay(1000);
  pulselen = map(Gripper_Rotation,0,180,SERVOMIN,SERVOMAX);
  pwm.setPWM(Rear_Arm[5],0,pulselen);
  delay(1000);*/
  return 0; 
}




int Arm_Front(float x, float y, float z,  float Wrist_Angle) //Here's all the Inverse Kinematics to control the arm
{
	 float grip_angle_r = radians( Wrist_Angle );    //grip angle in radians for use in calculations
  /* Base angle and radial distance from x,y coordinates */
  float bas_angle_r = atan2( x, y );
  float rdist = sqrt(( x * x ) + ( y * y ));
  /* rdist is y coordinate for the arm */
  y = rdist;
  /* Grip offsets calculated based on grip angle */
  float grip_off_z = ( sin( grip_angle_r )) * GRIPPER;
  float grip_off_y = ( cos( grip_angle_r )) * GRIPPER;
  /* Wrist position */
  float wrist_z = ( z - grip_off_z ) - BASE_HGT;
  float wrist_y = y - grip_off_y;
  /* Shoulder to wrist distance ( AKA sw ) */
  float s_w = ( wrist_z * wrist_z ) + ( wrist_y * wrist_y );
  float s_w_sqrt = sqrt( s_w );
  /* s_w angle to ground */
  //float a1 = atan2( wrist_y, wrist_z );
  float a1 = atan2( wrist_z, wrist_y );
  /* s_w angle to humerus */
  float a2 = acos((( hum_sq - uln_sq ) + s_w ) / ( 2 * HUMERUS * s_w_sqrt ));
  /* shoulder angle */
  float shl_angle_r = a1 + a2;
  float Shoulder= degrees( shl_angle_r );
  /* elbow angle */
  float elb_angle_r = acos(( hum_sq + uln_sq - s_w ) / ( 2 * HUMERUS * ULNA ));
  float elb_angle_d = degrees( elb_angle_r );
  float Elbow = -( 180.0 - elb_angle_d );
  /* wrist angle */
  float Wrist = ( Wrist_Angle - Elbow ) - Shoulder;
 float Base_Rotation= degrees( bas_angle_r );
  int pulselen;


  pulselen = map(Shoulder,0,180,SERVOMIN,SERVOMAX);
  pwm.setPWM(Front_Arm[1],0,pulselen);

  
  pulselen = map(-Elbow,0,180,SERVOMIN,SERVOMAX);
  pwm.setPWM(Front_Arm[2],0,pulselen);

  
  
  pulselen = map(180-Wrist,0,180,SERVOMIN,SERVOMAX);
  pwm.setPWM(Front_Arm[3],0,pulselen);


  pulselen = map(180-Base_Rotation,0,180,SERVOMIN,SERVOMAX);
  pwm.setPWM(Front_Arm[0],0,pulselen);
/*

  pulselen = map(Wrist,0,180,SERVOMIN,SERVOMAX);
  pwm.setPWM(Rear_Arm[4],0,pulselen);
 delay(1000);
  pulselen = map(Gripper_Rotation,0,180,SERVOMIN,SERVOMAX);
  pwm.setPWM(Rear_Arm[5],0,pulselen);
  delay(1000);*/
  return 0; 
}
