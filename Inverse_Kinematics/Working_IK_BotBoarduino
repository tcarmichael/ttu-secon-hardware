#include <Servo.h>
char foo;
#include <math.h>
#include <Wire.h>
//#define DEBUG

//comment to disable the Force Sensitive Resister on the gripper
//#define FSRG

//FSRG pin Must be analog!!
#define FSRG_pin A1

//Select which arm by uncommenting the corresponding line
//#define AL5A
//#define AL5B
#define AL5B

//uncomment for digital servos in the Shoulder and Elbow
//that use a range of 900ms to 2100ms
//#define DIGITAL_RANGE

#ifdef AL5A
const double A = 3.75;
const double B = 4.25;
#elif defined AL5B
const double A = 4.75;
const double B = 5.00;
#elif defined AL5D
const double A = 5.75;
const double B = 7.375;
#endif



//Arm Servo pins
#define Base_pin 2
#define Shoulder_pin 3
#define Elbow_pin 4
#define Wrist_pin 5
#define Gripper_pin 7
#define WristR_pin 6


//Radians to Degrees constant
const double rtod = 57.295779;

//Arm Speed Variables
double Speed = 1.0;
int sps = 3;

//Servo Objects
Servo Elb;
Servo Shldr;
Servo Wrist;
Servo Base;
Servo WristR;
Servo Gripper;

/*//Arm Current Pos
float X = 4;
float Y = 4;
int Z = 90;
int G = 90;
int WR = 90;
float WA = 0;

//Arm temp pos
float tmpx = 4;
float tmpy = 4;
int tmpz = 90;
int tmpg = 90;
int tmpwr = 90;
float tmpwa = 0;
*/

boolean mode = true;

void setup()
{
  Serial.begin(115200);

Base.attach(Base_pin);
Shldr.attach(Shoulder_pin);
Elb.attach(Elbow_pin);
Wrist.attach(Wrist_pin);
Gripper.attach(Gripper_pin);
WristR.attach(WristR_pin);

}






void loop()
{
	Arm_Rear_Home_Positive();
	Rear_Arm_IK( 0,6, 2, 90,90,-75 );
	delay(1500);
	Rear_Arm_IK( 0,6,0, 45,0,-75 );
	delay(1500);
	Rear_Arm_IK( 0,6, -1, 135,0,-75 );
	delay(1500);
	Rear_Arm_IK( 0,6, 4, 135,0,-75 );
	delay(1500);


		
/*Rear_Arm_IK( 4, 0, 0, 90,90,-80 );
			delay(1500);*/
	//zero_xz();
	//zero_y();
	/*Arm(4, 3, 50, 90, 90, -75);
	delay(1500);
	Arm(4, 0, 50, 90, 90, -75);
	delay(1500);*/
	
}




int Rear_Arm_IK(double x, double y, double z, int g, double wr, int wa) // Note xy are coordinates in the ground plane and z is the vertical plane
{
	double r=sqrt(x*x+y*y);
	z=z+r*(.5);
	//wa=wa+1.5*r;
	double Base_Rotation=degrees(atan2(y,x));
	double M = sqrt((z*z)+(r*r));
  if(M <= 0)
    return 1;
  double A1 = atan(z/r);
  if(r <= 0)
    return 1;
  double A2 = acos((A*A-B*B+M*M)/((A*2)*M));
  double Elbow = acos((A*A+B*B-M*M)/((A*2)*B));
  double Shoulder = A1 + A2;
  Elbow = Elbow * rtod;
  Shoulder = Shoulder * rtod;
  if((int)Elbow <= 0 || (int)Shoulder <= 0)
    return 1;
  double Wris = abs(wa - Elbow - Shoulder) - 90;
#ifdef DIGITAL_RANGE
  Elb.writeMicroseconds(map(180 - Elbow, 0, 180, 900, 2100  ));
  Shldr.writeMicroseconds(map(Shoulder, 0, 180, 900, 2100));
#else
  Elb.write(180 - Elbow);
  Shldr.write(Shoulder);
#endif
  Wrist.write(180 - Wris);
  Base.write(Base_Rotation);
  WristR.write(wr);
  #ifndef FSRG
  Gripper.write(g);
  #endif
 
  return 0; 
}



void Front_Arm_IK(double x, double y, double z, int g, double wr, double wa)
{
}

void zero_xy()
{
  for( double zaxis = 0; zaxis < 5; zaxis += .1 ) {
	  Rear_Arm_IK( 0, 4, zaxis, 90,90,-75 );
    delay( 100 );
  }
  for( double zaxis = 5; zaxis > 0; zaxis -= .1 ) {
    Rear_Arm_IK( 0,4 , zaxis, 90,90,-75);
    delay( 100 );
  }
}

void zero_yz()
{
  for( double xaxis = 3; xaxis < 6; xaxis += .1 ) {
	  Rear_Arm_IK( xaxis, 4, 0, 90,90,-75 );
    delay( 100 );
  }
  for( double xaxis = 6; xaxis > 3; xaxis -= .1 ) {
    Rear_Arm_IK(xaxis, 4, 0, 90,90,-75);
    delay( 100);
  }
}
void zero_xz()
{
  for( double yaxis = 3; yaxis < 6; yaxis += .1 ) {
	  Rear_Arm_IK( 0, yaxis, 0, 90,90,-75 );
    delay( 100 );
  }
  for( double yaxis = 6; yaxis > 3; yaxis -= .1 ) {
    Rear_Arm_IK(0, yaxis, 0, 90,90,-75);
    delay( 100);
  }
}

void Etch_Pull()
{
}
void Etch_Grasp()
{
}
void Simon_Play()
{
}
void Simon_Grab()
{
}
void Card_Grab()
{
}
void Rubiks_Grab()
{
}
void Rubiks_Rotate()
{
}
void Arm_Front_Home()
{
}

void Arm_Rear_Home_Positive()
{
	Rear_Arm_IK( 1,0, 2, 90,90,-30 );
		delay(1500);
}
void Arm_Rear_Home_Negative()
{
	Rear_Arm_IK( -1,0, 2, 90,90,-30 );
		delay(1500);
}
void Rear_Flip_To_Negative()
{
	Rear_Arm_IK( 3,0, 5, 90,90,0 );
	delay(1000);

	Rear_Arm_IK( -3,0, 5, 90,90,0 );
	delay(1000);



	
}

void Rear_Flip_To_Positive()
{
	Rear_Arm_IK( -3,0, 5, 90,90,0 );
	delay(1000);

	Rear_Arm_IK( 3,0, 5, 90,90,0 );
	delay(1000);
}
