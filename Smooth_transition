/* Smoothes the transitions from one position to the next.
Moves from claw joint to base. Except for joint 2 and 3 are 
switched.  Can edit transition to increment hirer than 1 degree.*/

#include <Wire.h>
#include <Adafruit_MotorShield.h>
#include <Mecanum.h>

Adafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver();

#define SERVOMIN 150
#define SERVOMAX 600

#define DEBUG

const int NUM_SERVOS = 6;
const int Front_Arm[NUM_SERVOS] = {10,11,12,13,14,15};
const int Rear_Arm[NUM_SERVOS] = {0,1,2,3,4,5};
int start[NUM_SERVOS] ={180,120,40,90,90,90};
int newposition[NUM_SERVOS] = {180,80,108,118,90,60};

void setup() {
  // put your setup code here, to run once:
  Serial.begin(9600);
  pwm.begin();
  pwm.setPWMFreq(60);
 
  smooth(start,newposition,Rear_Arm,SERVOMIN,SERVOMAX);
  
}

void loop() {
  // put your main code here, to run repeatedly:
  
}

//minimum and maximum is SERVOMIN and SEVRVOMAX from arm program
void smooth(int start[],int newposition[],const int arm[],const int minimum, const int maximum)
{
  int a,b,c,d,e,f;
  a = Rear_Arm[0]; b = Rear_Arm[1]; c = Rear_Arm[2];
  d = Rear_Arm[3]; e = Rear_Arm[4]; f = Rear_Arm[5];
  int newarm[NUM_SERVOS] = {a,c,b,d,e,f};
  int pulselen;
  for(int servoIndex = sizeof(start)-1; servoIndex >= 0; servoIndex--)
  {
    if(start[servoIndex] < newposition[servoIndex])
    {
      for(int rotate = start[servoIndex]; rotate <= newposition[servoIndex]; rotate++)
      {
        pulselen = map(rotate,0,180,minimum,maximum);
        pwm.setPWM(newarm[servoIndex],0,pulselen);
        delay(15);
      }
    }
    else
    {
      for(int rotate = start[servoIndex]; rotate >= newposition[servoIndex]; rotate++)
      {
        pulselen = map(rotate,0,180,minimum,maximum);
        pwm.setPWM(newarm[servoIndex],0,pulselen);
        delay(15);
      }
    }
  }
}
